diff -ur ../../TMP_LIBS/ESP32-A2DP/CMakeLists.txt ESP32-A2DP/CMakeLists.txt
--- ../../TMP_LIBS/ESP32-A2DP/CMakeLists.txt	2025-05-05 15:28:15.665789300 +0900
+++ ESP32-A2DP/CMakeLists.txt	2025-01-13 02:00:48.566987000 +0900
@@ -5,7 +5,7 @@
 idf_component_register(
     SRC_DIRS src
     INCLUDE_DIRS src 
-    REQUIRES bt esp_common freertos hal log nvs_flash driver
+    REQUIRES bt esp_common freertos hal log nvs_flash driver arduino
 )
 
 target_compile_options(${COMPONENT_LIB} PUBLIC -DA2DP_LEGACY_I2S_SUPPORT=1 -DA2DP_I2S_AUDIOTOOLS=0 -Wno-error -Wno-format -fpermissive)
diff -ur ../../TMP_LIBS/ESP32-A2DP/src/BluetoothA2DPSource.cpp ESP32-A2DP/src/BluetoothA2DPSource.cpp
--- ../../TMP_LIBS/ESP32-A2DP/src/BluetoothA2DPSource.cpp	2025-05-05 15:28:15.861972600 +0900
+++ ESP32-A2DP/src/BluetoothA2DPSource.cpp	2026-02-14 21:39:40.638548900 +0900
@@ -14,6 +14,9 @@
 // Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
 
 #include "BluetoothA2DPSource.h"
+#if 1
+#include <Esp.h>
+#endif
 
 #define BT_APP_SIG_WORK_DISPATCH (0x01)
 #define BT_APP_SIG_WORK_DISPATCH (0x01)
@@ -59,6 +62,14 @@
     self_BluetoothA2DPSource->bt_app_rc_ct_cb(event, param);
 }
 
+#if 1
+extern "C" void ccall_bt_app_rc_tg_cb(esp_avrc_tg_cb_event_t event,
+                                      esp_avrc_tg_cb_param_t *param) {
+  if (self_BluetoothA2DPSource)
+    self_BluetoothA2DPSource->bt_app_rc_tg_cb(event, param);
+}
+#endif
+
 extern "C" void ccall_a2d_app_heart_beat(TIMER_ARG_TYPE arg) {
   if (self_BluetoothA2DPSource)
     self_BluetoothA2DPSource->a2d_app_heart_beat(arg);
@@ -80,6 +91,13 @@
     self_BluetoothA2DPSource->bt_av_hdl_avrc_ct_evt(event, param);
 }
 
+#if 1
+extern "C" void ccall_bt_av_hdl_avrc_tg_evt(uint16_t event, void *param) {
+  if (self_BluetoothA2DPSource)
+    self_BluetoothA2DPSource->bt_av_hdl_avrc_tg_evt(event, param);
+}
+#endif
+
 extern "C" int32_t ccall_bt_app_a2d_data_cb(uint8_t *data, int32_t len) {
   // ESP_LOGD(BT_APP_TAG, "x%x - len: %d", __func__, len);
   if (len <= 0 || data == NULL || self_BluetoothA2DPSource == NULL ||
@@ -356,9 +374,21 @@
 
   rmt_bdname = esp_bt_gap_resolve_eir_data(eir, ESP_BT_EIR_TYPE_CMPL_LOCAL_NAME,
                                            &rmt_bdname_len);
+#if 0
+  if (rmt_bdname) {
+    rmt_bdname[rmt_bdname_len] = 0x0;
+    ESP_LOGW(BT_AV_TAG, "BDNAME1: %s", rmt_bdname);
+  }
+#endif
   if (!rmt_bdname) {
     rmt_bdname = esp_bt_gap_resolve_eir_data(
         eir, ESP_BT_EIR_TYPE_SHORT_LOCAL_NAME, &rmt_bdname_len);
+#if 0
+    if (rmt_bdname) {
+      rmt_bdname[rmt_bdname_len] = 0x0;
+      ESP_LOGW(BT_AV_TAG, "BDNAME2: %s", rmt_bdname);
+    }
+#endif
   }
 
   if (rmt_bdname) {
@@ -386,7 +416,11 @@
   uint8_t *eir = NULL;
   esp_bt_gap_dev_prop_t *p;
 
+#if 1
+  ESP_LOGW(BT_AV_TAG, "Scanned device: %s", to_str(param->disc_res.bda));
+#else
   ESP_LOGI(BT_AV_TAG, "Scanned device: %s", to_str(param->disc_res.bda));
+#endif
   for (int i = 0; i < param->disc_res.num_prop; i++) {
     p = param->disc_res.prop + i;
     switch (p->type) {
@@ -409,16 +443,35 @@
   /* search for device with MAJOR service class as "rendering" in COD */
   if (!esp_bt_gap_is_valid_cod(cod) ||
       !(esp_bt_gap_get_cod_srvc(cod) & ESP_BT_COD_SRVC_RENDERING)) {
+#if 1
+    ESP_LOGW(BT_AV_TAG, "--Compatiblity: Incompatible");
+#else
     ESP_LOGI(BT_AV_TAG, "--Compatiblity: Incompatible");
+#endif
     return;
   }
 
   /* search for target device in its Extended Inqury Response */
   if (eir) {
 
+#if 1
+    ESP_LOGW(BT_AV_TAG, "--Compatiblity: Compatible");
+#else
     ESP_LOGI(BT_AV_TAG, "--Compatiblity: Compatible");
+#endif
+#if 1
+    if (false == get_name_from_eir(eir, s_peer_bdname, NULL)) {
+      ESP_LOGW(BT_AV_TAG, "get_name_from_eir returns false");
+      strcpy(s_peer_bdname, "[Unknown]");
+    }
+#else
     get_name_from_eir(eir, s_peer_bdname, NULL);
+#endif
+#if 1
+    ESP_LOGW(BT_AV_TAG, "--Name: %s", s_peer_bdname);
+#else
     ESP_LOGI(BT_AV_TAG, "--Name: %s", s_peer_bdname);
+#endif
 
     // check ssid names from provided list
     bool found = false;
@@ -430,7 +483,11 @@
       // if no callback we use the list
       for (const char *name : bt_names) {
         int len = strlen(name);
+#if 1
+        ESP_LOGW(BT_AV_TAG, "--Checking match: %s", name);
+#else
         ESP_LOGD(BT_AV_TAG, "--Checking match: %s", name);
+#endif
         if (strncmp((char *)s_peer_bdname, name, len) == 0) {
           this->bt_name = (char *)s_peer_bdname;
           found = true;
@@ -439,21 +496,38 @@
       }
     }
     if (found) {
+#if 1
+      ESP_LOGW(BT_AV_TAG, "--Result: Target device found");
+#else
       ESP_LOGI(BT_AV_TAG, "--Result: Target device found");
+#endif
       s_a2d_state = APP_AV_STATE_DISCOVERED;
       memcpy(peer_bd_addr, param->disc_res.bda, ESP_BD_ADDR_LEN);
       set_last_connection(peer_bd_addr);
+#if 1
+      ESP_LOGW(BT_AV_TAG, "Cancel device discovery ...");
+#else
       ESP_LOGI(BT_AV_TAG, "Cancel device discovery ...");
+#endif
       esp_bt_gap_cancel_discovery();
     } else {
+#if 1
+      ESP_LOGW(BT_AV_TAG, "--Result: Target device not found");
+#else
       ESP_LOGI(BT_AV_TAG, "--Result: Target device not found");
+#endif
+      //vTaskDelay(1000);
     }
   }
 }
 
 void BluetoothA2DPSource::bt_app_gap_callback(esp_bt_gap_cb_event_t event,
                                               esp_bt_gap_cb_param_t *param) {
+#if 0
+  ESP_LOGW(BT_AV_TAG, "%s evt %d", __func__, event);
+#else
   ESP_LOGD(BT_AV_TAG, "%s evt %d", __func__, event);
+#endif
   switch (event) {
   case ESP_BT_GAP_DISC_RES_EVT: {
     filter_inquiry_scan_result(param);
@@ -463,16 +537,56 @@
     if (param->disc_st_chg.state == ESP_BT_GAP_DISCOVERY_STOPPED) {
       if (s_a2d_state == APP_AV_STATE_DISCOVERED) {
         s_a2d_state = APP_AV_STATE_CONNECTING;
+#if 1
+        ESP_LOGW(BT_AV_TAG, "Device discovery stopped.");
+        ESP_LOGW(BT_AV_TAG, "a2dp connecting to peer: %s", s_peer_bdname);
+#else
         ESP_LOGI(BT_AV_TAG, "Device discovery stopped.");
         ESP_LOGI(BT_AV_TAG, "a2dp connecting to peer: %s", s_peer_bdname);
+#endif
         esp_a2d_connect(peer_bd_addr);
       } else {
         // not discovered, continue to discover
+#if 1
+        ESP_LOGW(BT_AV_TAG, "Device discovery failed, continue to discover...");
+        if (s_a2d_state == APP_AV_STATE_CONNECTED) {
+          ESP_LOGW(BT_AV_TAG, "Device already connected. Ignoring it...");
+          break;
+        }
+        if (++discovery_failed_count >= 20) {
+          ESP_LOGW(BT_AV_TAG, "Device discovery failed (%d), rebooting...", discovery_failed_count);
+          ESP.restart();
+        }
+        //static int discovery_failed = 0;
+        //if (0 && ++discovery_failed >= 100) {
+        //  ESP_LOGW(BT_AV_TAG, "Device discovery failed, rebooting...");
+        //  ESP.restart();
+        //} else {
+        //  ESP_LOGW(BT_AV_TAG, "Device discovery failed, continue to discover...");
+        //}
+#else
         ESP_LOGI(BT_AV_TAG, "Device discovery failed, continue to discover...");
+#endif
+#if 1
+        esp_err_t rv = esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, 10, 0);
+        //ESP_LOGW(BT_AV_TAG, "rv = %d", rv);
+        if (rv != ESP_OK) {
+          ESP_LOGW(BT_AV_TAG, "rv = %d (!= 0)", rv);
+          ESP.restart();
+        }
+#else
         esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, 10, 0);
+#endif
       }
     } else if (param->disc_st_chg.state == ESP_BT_GAP_DISCOVERY_STARTED) {
+#if 1
+      discovering_count = 1;
+#endif
+#if 1
+      ESP_LOGW(BT_AV_TAG, "Discovery started. (%d)", discovery_failed_count);
+#else
       ESP_LOGI(BT_AV_TAG, "Discovery started.");
+#endif
     }
     break;
   }
@@ -531,6 +645,7 @@
     esp_bt_gap_ssp_confirm_reply(param->cfm_req.bda, true);
     break;
 
+#if 1 /* XXX */
 #if ESP_IDF_VERSION > ESP_IDF_VERSION_VAL(4, 4, 4)
   case ESP_BT_GAP_ACL_CONN_CMPL_STAT_EVT:
     ESP_LOGI( BT_AV_TAG,"ESP_BT_GAP_ACL_CONN_CMPL_STAT_EVT");
@@ -541,6 +656,7 @@
              param->mode_chg.mode);
     break;
 #endif
+#endif /* XXX */
 
   default: {
     ESP_LOGI(BT_AV_TAG, "event: %d", event);
@@ -550,8 +666,16 @@
   return;
 }
 
+#if 1
+extern int btu_connecting_count;
+#endif
+
 void BluetoothA2DPSource::bt_av_hdl_stack_evt(uint16_t event, void *p_param) {
+#if 0
+  ESP_LOGW(BT_AV_TAG, "%s event: %d", __func__, event);
+#else
   ESP_LOGD(BT_AV_TAG, "%s event: %d", __func__, event);
+#endif
 
   switch (event) {
   /* when stack up worked, this event comes */
@@ -565,12 +689,23 @@
     esp_avrc_ct_init();
     esp_avrc_ct_register_callback(ccall_bt_app_rc_ct_cb);
 
+#if 1 /* Enabling Target */
+    assert(esp_avrc_tg_init() == ESP_OK);
+    esp_avrc_tg_register_callback(ccall_bt_app_rc_tg_cb); // along with the necessary functions to support this
+
+    esp_avrc_psth_bit_mask_t cmd_set = {0};
+    esp_avrc_tg_get_psth_cmd_filter(ESP_AVRC_PSTH_FILTER_ALLOWED_CMD, &cmd_set);
+    esp_avrc_tg_set_psth_cmd_filter(ESP_AVRC_PSTH_FILTER_SUPPORTED_CMD, &cmd_set);
+#endif
+
+#if 0 /* XXX */
 #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
     esp_avrc_rn_evt_cap_mask_t evt_set = {0};
     esp_avrc_rn_evt_bit_mask_operation(ESP_AVRC_BIT_MASK_OP_SET, &evt_set,
                                        ESP_AVRC_RN_VOLUME_CHANGE);
     assert(esp_avrc_tg_set_rn_evt_cap(&evt_set) == ESP_OK);
 #endif
+#endif /* XXX */
 
     esp_a2d_source_init();
     esp_a2d_register_callback(&ccall_bt_app_a2d_cb);
@@ -581,15 +716,32 @@
     //esp_bt_gap_set_scan_mode(ESP_BT_NON_CONNECTABLE, ESP_BT_NON_DISCOVERABLE);
     set_scan_mode_connectable(false);
     if (reconnect_status == AutoReconnect && has_last_connection()) {
+#if 1
+      btu_connecting_count = 0;
+#endif
       ESP_LOGW(BT_AV_TAG, "Reconnecting to %s", to_str(last_connection));
       memcpy(peer_bd_addr, last_connection, ESP_BD_ADDR_LEN);
       connect_to(last_connection);
       s_a2d_state = APP_AV_STATE_CONNECTING;
     } else {
 
+#if 1
+      discovery_failed_count = 0;
+      ESP_LOGW(BT_AV_TAG, "Starting device discovery...");
+#else
       ESP_LOGI(BT_AV_TAG, "Starting device discovery...");
+#endif
       s_a2d_state = APP_AV_STATE_DISCOVERING;
+#if 1
+      esp_err_t rv = esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, 10, 0);
+      //ESP_LOGW(BT_AV_TAG, "rv = %d", rv);
+      if (rv != ESP_OK) {
+        ESP_LOGW(BT_AV_TAG, "rv = %d (!= 0)", rv);
+        ESP.restart();
+      }
+#else
       esp_bt_gap_start_discovery(ESP_BT_INQ_MODE_GENERAL_INQUIRY, 10, 0);
+#endif
     }
     /* create and start heart beat timer */
       int tmr_id = 0;
@@ -652,12 +804,25 @@
 }
 
 void BluetoothA2DPSource::bt_app_av_sm_hdlr(uint16_t event, void *param) {
+#if 0
+  ESP_LOGW(BT_AV_TAG, "%s state %s, evt 0x%x", __func__, to_state_str(s_a2d_state), event);
+#else
   ESP_LOGI(BT_AV_TAG, "%s state %s, evt 0x%x", __func__, to_state_str(s_a2d_state), event);
+#endif
   process_user_state_callbacks(event, param);
 
   /* select handler according to different states */
   switch (s_a2d_state) {
   case APP_AV_STATE_DISCOVERING:
+#if 0 /* XXX */
+    ESP_LOGE(BT_AV_TAG, "s_a2d_state is Discovering: %d", discovering_count);
+#endif
+#if 1 /* XXX */
+    if (++discovering_count >= 5) {
+      ESP_LOGE(BT_AV_TAG, "Discovery count exceeded: %d", discovering_count);
+      ESP.restart();
+    }
+#endif
   case APP_AV_STATE_DISCOVERED:
     break;
   case APP_AV_STATE_UNCONNECTED:
@@ -691,6 +856,13 @@
     break;
   case BT_APP_HEART_BEAT_EVT: {
     esp_a2d_connect(peer_bd_addr);
+#if 1
+    ESP_LOGW(BT_AV_TAG, "Reconnecting to peer %s", to_str(peer_bd_addr));
+    if (++btu_connecting_count >= 3) {
+      ESP_LOGW(BT_AV_TAG, "Reconnecting count exceeded: %d", btu_connecting_count);
+      ESP.restart();
+    }
+#endif
     s_a2d_state = APP_AV_STATE_CONNECTING;
     s_connecting_heatbeat_count = 0;
     break;
@@ -709,7 +881,11 @@
 
 void BluetoothA2DPSource::bt_app_av_state_connecting_hdlr(uint16_t event,
                                                           void *param) {
+#if 0
+  ESP_LOGW(BT_AV_TAG, "%s evt %d", __func__, event);
+#else
   ESP_LOGD(BT_AV_TAG, "%s evt %d", __func__, event);
+#endif
   esp_a2d_cb_param_t *a2d = NULL;
 
   /* handle the events of intrest in connecting state */
@@ -737,6 +913,10 @@
     if (++s_connecting_heatbeat_count >= 2) {
       s_a2d_state = APP_AV_STATE_UNCONNECTED;
       s_connecting_heatbeat_count = 0;
+#if 0
+      ESP_LOGW(BT_AV_TAG, "s_connecting_heatbeat_count = %d", s_connecting_heatbeat_count);
+      ESP.restart();
+#endif
     }
     break;
   // case ESP_A2D_REPORT_SNK_DELAY_VALUE_EVT: {
@@ -886,17 +1066,23 @@
 
 void BluetoothA2DPSource::bt_app_rc_ct_cb(esp_avrc_ct_cb_event_t event,
                                           esp_avrc_ct_cb_param_t *param) {
+#if 0
+  ESP_LOGW(BT_RC_CT_TAG, "%s evt %d", __func__, event);
+#else
   ESP_LOGD(BT_RC_CT_TAG, "%s evt %d", __func__, event);
+#endif
   switch (event) {
   case ESP_AVRC_CT_CONNECTION_STATE_EVT:
   case ESP_AVRC_CT_PASSTHROUGH_RSP_EVT:
   case ESP_AVRC_CT_METADATA_RSP_EVT:
   case ESP_AVRC_CT_CHANGE_NOTIFY_EVT:
   case ESP_AVRC_CT_REMOTE_FEATURES_EVT:
+#if 0 /* XXX */
 #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
   case ESP_AVRC_CT_GET_RN_CAPABILITIES_RSP_EVT:
   case ESP_AVRC_CT_SET_ABSOLUTE_VOLUME_RSP_EVT: 
 #endif
+#endif
   {
     bt_app_work_dispatch(ccall_bt_av_hdl_avrc_ct_evt, event, param,
                          sizeof(esp_avrc_ct_cb_param_t), NULL);
@@ -909,49 +1095,107 @@
   }
 }
 
+#if 1
+void BluetoothA2DPSource::bt_app_rc_tg_cb(esp_avrc_tg_cb_event_t event,
+                                          esp_avrc_tg_cb_param_t *param) {
+#if 0
+  ESP_LOGW("BT_RC_TG_TAG", "%s evt %d", __func__, event);
+#else
+  ESP_LOGD("BT_RC_TG_TAG", "%s evt %d", __func__, event);
+#endif
+  switch (event) {
+  case ESP_AVRC_TG_CONNECTION_STATE_EVT:
+  case ESP_AVRC_TG_REMOTE_FEATURES_EVT:
+  case ESP_AVRC_TG_PASSTHROUGH_CMD_EVT:
+  case ESP_AVRC_TG_SET_ABSOLUTE_VOLUME_CMD_EVT:
+  case ESP_AVRC_TG_REGISTER_NOTIFICATION_EVT:
+  case ESP_AVRC_TG_SET_PLAYER_APP_VALUE_EVT:
+  {
+    bt_app_work_dispatch(ccall_bt_av_hdl_avrc_tg_evt, event, param,
+                         sizeof(esp_avrc_tg_cb_param_t), NULL);
+    break;
+  }
+  default: {
+    ESP_LOGW("BT_RC_TG_TAG", "Unhandled AVRC event: %d", event);
+    break;
+  }
+  }
+}
+#endif
+
+#if 0 /* XXX */
 #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
 
 void BluetoothA2DPSource::bt_av_volume_changed(void) {
   if (esp_avrc_rn_evt_bit_mask_operation(ESP_AVRC_BIT_MASK_OP_TEST,
                                          &s_avrc_peer_rn_cap,
                                          ESP_AVRC_RN_VOLUME_CHANGE)) {
+#if 0 /* XXX */
+    esp_err_t rv =
+    esp_avrc_ct_send_register_notification_cmd(APP_RC_CT_TL_RN_VOLUME_CHANGE,
+                                               ESP_AVRC_RN_VOLUME_CHANGE, 0);
+    ESP_LOGW(BT_RC_CT_TAG, "bt_av_volume_changed() Debug2: %d", rv);
+#else
     esp_avrc_ct_send_register_notification_cmd(APP_RC_CT_TL_RN_VOLUME_CHANGE,
                                                ESP_AVRC_RN_VOLUME_CHANGE, 0);
+#endif
   }
 }
 
 void BluetoothA2DPSource::bt_av_notify_evt_handler(
     uint8_t event_id, esp_avrc_rn_param_t *event_parameter) {
+#if 0 /* XXX */
+  ESP_LOGW(BT_RC_CT_TAG, "%s evt %d", __func__, event_id);
+#else
   ESP_LOGD(BT_RC_CT_TAG, "%s evt %d", __func__, event_id);
+#endif
   switch (event_id) {
+#if 0
   case ESP_AVRC_RN_VOLUME_CHANGE:
     ESP_LOGI(BT_RC_CT_TAG, "Volume changed: %d", event_parameter->volume);
     // limit the value to 127
     uint8_t new_volume = std::min((int)event_parameter->volume, 0x7f);
     ESP_LOGI(BT_RC_CT_TAG, "Set absolute volume: volume %d", new_volume);
+#if 0 /* XXX */
+    ESP_LOGW(BT_RC_CT_TAG, "Set absolute volume: volume %d", new_volume);
+#endif
     esp_avrc_ct_send_set_absolute_volume_cmd(APP_RC_CT_TL_RN_VOLUME_CHANGE,
                                              new_volume);
     set_volume(new_volume);
     bt_av_volume_changed();
     break;
+#endif
   }
 }
 
 #endif
+#endif /* XXX */
 
 void BluetoothA2DPSource::bt_av_hdl_avrc_ct_evt(uint16_t event, void *p_param) {
+#if 0 /* XXX */
+  ESP_LOGW(BT_RC_CT_TAG, "%s evt %d", __func__, event);
+#else
   ESP_LOGD(BT_RC_CT_TAG, "%s evt %d", __func__, event);
+#endif
   esp_avrc_ct_cb_param_t *rc = (esp_avrc_ct_cb_param_t *)(p_param);
 
   switch (event) {
   /* when connection state changed, this event comes */
   case ESP_AVRC_CT_CONNECTION_STATE_EVT: {
     [[maybe_unused]] uint8_t *bda = rc->conn_stat.remote_bda;
+#if 0
+    ESP_LOGW(BT_RC_CT_TAG,
+             "AVRC conn_state event: state %d, [%02x:%02x:%02x:%02x:%02x:%02x]",
+             rc->conn_stat.connected, bda[0], bda[1], bda[2], bda[3], bda[4],
+             bda[5]);
+#else
     ESP_LOGI(BT_RC_CT_TAG,
              "AVRC conn_state event: state %d, [%02x:%02x:%02x:%02x:%02x:%02x]",
              rc->conn_stat.connected, bda[0], bda[1], bda[2], bda[3], bda[4],
              bda[5]);
 
+#endif
+#if 1 /* XXX */
 #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
     if (rc->conn_stat.connected) {
       esp_avrc_ct_send_get_rn_capabilities_cmd(APP_RC_CT_TL_GET_CAPS);
@@ -959,59 +1203,100 @@
       s_avrc_peer_rn_cap.bits = 0;
     }
 #endif
+#endif /* XXX */
     break;
   }
   /* when passthrough responsed, this event comes */
   case ESP_AVRC_CT_PASSTHROUGH_RSP_EVT: {
+#if 0
+    ESP_LOGW(
+        BT_RC_CT_TAG,
+        "AVRC passthrough response: key_code 0x%x, key_state %d, rsp_code %d",
+        rc->psth_rsp.key_code, rc->psth_rsp.key_state, rc->psth_rsp.rsp_code);
+#else
     ESP_LOGI(
         BT_RC_CT_TAG,
         "AVRC passthrough response: key_code 0x%x, key_state %d, rsp_code %d",
         rc->psth_rsp.key_code, rc->psth_rsp.key_state, rc->psth_rsp.rsp_code);
+#endif
     break;
   }
   /* when metadata responsed, this event comes */
   case ESP_AVRC_CT_METADATA_RSP_EVT: {
+#if 0
+    ESP_LOGW(BT_RC_CT_TAG, "AVRC metadata response: attribute id 0x%x, %s",
+             rc->meta_rsp.attr_id, rc->meta_rsp.attr_text);
+#else
     ESP_LOGI(BT_RC_CT_TAG, "AVRC metadata response: attribute id 0x%x, %s",
              rc->meta_rsp.attr_id, rc->meta_rsp.attr_text);
+#endif
     free(rc->meta_rsp.attr_text);
     break;
   }
   /* when notification changed, this event comes */
   case ESP_AVRC_CT_CHANGE_NOTIFY_EVT: {
+#if 0
+    ESP_LOGW(BT_RC_CT_TAG, "AVRC event notification: %d",
+             rc->change_ntf.event_id);
+#else
     ESP_LOGI(BT_RC_CT_TAG, "AVRC event notification: %d",
              rc->change_ntf.event_id);
+#endif
+#if 0 /* XXX */
 #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
     bt_av_notify_evt_handler(rc->change_ntf.event_id,
                              &rc->change_ntf.event_parameter);
 #endif
+#endif /* XXX */
     break;
   }
   /* when indicate feature of remote device, this event comes */
   case ESP_AVRC_CT_REMOTE_FEATURES_EVT: {
+#if 0
+    ESP_LOGW(BT_RC_CT_TAG, "AVRC remote features %" PRIx32 ", TG features %x",
+             rc->rmt_feats.feat_mask, rc->rmt_feats.tg_feat_flag);
+#else
     ESP_LOGI(BT_RC_CT_TAG, "AVRC remote features %" PRIx32 ", TG features %x",
              rc->rmt_feats.feat_mask, rc->rmt_feats.tg_feat_flag);
+#endif
     break;
   }
 
+#if 0 /* XXX */
 #if ESP_IDF_VERSION >= ESP_IDF_VERSION_VAL(4, 0, 0)
   /* when get supported notification events capability of peer device, this
    * event comes */
   case ESP_AVRC_CT_GET_RN_CAPABILITIES_RSP_EVT: {
+#if 0
+    ESP_LOGW(BT_RC_CT_TAG, "remote rn_cap: count %d, bitmask 0x%x",
+             rc->get_rn_caps_rsp.cap_count, rc->get_rn_caps_rsp.evt_set.bits);
+#else
     ESP_LOGI(BT_RC_CT_TAG, "remote rn_cap: count %d, bitmask 0x%x",
              rc->get_rn_caps_rsp.cap_count, rc->get_rn_caps_rsp.evt_set.bits);
+#endif
     s_avrc_peer_rn_cap.bits = rc->get_rn_caps_rsp.evt_set.bits;
 
     bt_av_volume_changed();
     break;
   }
+#if 1
   /* when set absolute volume responsed, this event comes */
   case ESP_AVRC_CT_SET_ABSOLUTE_VOLUME_RSP_EVT: {
+#if 0 /* XXX */
+    ESP_LOGW(BT_RC_CT_TAG, "Set absolute volume response: volume %d",
+             rc->set_volume_rsp.volume);
+#else
     ESP_LOGI(BT_RC_CT_TAG, "Set absolute volume response: volume %d",
              rc->set_volume_rsp.volume);
+#endif
+#if 0
     set_volume(rc->set_volume_rsp.volume);
+#endif
     break;
   }
 #endif
+#endif
+#endif /* XXX */
   /* other */
   default: {
     ESP_LOGW(BT_RC_CT_TAG, "%s unhandled event: %d", __func__, event);
@@ -1020,6 +1305,50 @@
   }
 }
 
+#if 1
+int bt_prev_pushed = 0;
+int bt_next_pushed = 0;
+#endif
+
+#if 1
+void BluetoothA2DPSource::bt_av_hdl_avrc_tg_evt(uint16_t event, void *p_param) {
+#if 0
+  ESP_LOGD("BT_RC_TG_TAG", "%s evt %d", __func__, event);
+#else
+  ESP_LOGW("BT_RC_TG_TAG", "%s evt %d", __func__, event);
+#endif
+  esp_avrc_tg_cb_param_t *rc = (esp_avrc_tg_cb_param_t *)(p_param);
+
+  switch (event) {
+  case ESP_AVRC_TG_PASSTHROUGH_CMD_EVT: {
+#if 1
+    ESP_LOGW(
+        "BT_RC_TG_TAG",
+        "AVRC passthrough command: key_code 0x%x, key_state %d",
+        rc->psth_cmd.key_code, rc->psth_cmd.key_state);
+#else
+    ESP_LOGI(
+        "BT_RC_TG_TAG",
+        "AVRC passthrough command: key_code 0x%x, key_state %d",
+        rc->psth_cmd.key_code, rc->psth_cmd.key_state);
+#endif
+    if (rc->psth_cmd.key_state == 1) {
+        switch (rc->psth_cmd.key_code) {
+        case 0x4b: bt_next_pushed = 1; break;
+        case 0x4c: bt_prev_pushed = 1; break;
+        }
+    }
+    break;
+  }
+  /* other */
+  default: {
+    ESP_LOGI(BT_RC_CT_TAG, "%s unhandled event: %d", __func__, event);
+    break;
+  }
+  }
+}
+#endif
+
 bool BluetoothA2DPSource::has_sound_data() { return this->has_sound_data_flag; }
 
 bool BluetoothA2DPSource::write_data(SoundData *data) {
diff -ur ../../TMP_LIBS/ESP32-A2DP/src/BluetoothA2DPSource.h ESP32-A2DP/src/BluetoothA2DPSource.h
--- ../../TMP_LIBS/ESP32-A2DP/src/BluetoothA2DPSource.h	2025-05-05 15:28:15.862987500 +0900
+++ ESP32-A2DP/src/BluetoothA2DPSource.h	2026-02-14 13:58:16.394391600 +0900
@@ -36,10 +36,16 @@
 extern "C" void ccall_bt_app_task_handler(void *arg);
 extern "C" void ccall_bt_app_gap_callback(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param);
 extern "C" void ccall_bt_app_rc_ct_cb(esp_avrc_ct_cb_event_t event, esp_avrc_ct_cb_param_t *param);
+#if 1
+extern "C" void ccall_bt_app_rc_tg_cb(esp_avrc_tg_cb_event_t event, esp_avrc_tg_cb_param_t *param);
+#endif
 extern "C" void ccall_a2d_app_heart_beat(TIMER_ARG_TYPE arg) ;
 extern "C" void ccall_bt_app_a2d_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param);
 extern "C" void ccall_bt_app_av_sm_hdlr(uint16_t event, void *param);
 extern "C" void ccall_bt_av_hdl_avrc_ct_evt(uint16_t event, void *param) ;
+#if 1
+extern "C" void ccall_bt_av_hdl_avrc_tg_evt(uint16_t event, void *param) ;
+#endif
 extern "C" int32_t ccall_bt_app_a2d_data_cb(uint8_t *data, int32_t len);
 extern "C" int32_t ccall_get_channel_data_wrapper(uint8_t *data, int32_t len) ;
 extern "C" int32_t ccall_get_data_default(uint8_t *data, int32_t len) ;
@@ -78,10 +84,16 @@
   friend void ccall_bt_app_task_handler(void *arg);
   friend void ccall_bt_app_gap_callback(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param);
   friend void ccall_bt_app_rc_ct_cb(esp_avrc_ct_cb_event_t event, esp_avrc_ct_cb_param_t *param);
+#if 1
+  friend void ccall_bt_app_rc_tg_cb(esp_avrc_tg_cb_event_t event, esp_avrc_tg_cb_param_t *param);
+#endif
   friend void ccall_a2d_app_heart_beat(TIMER_ARG_TYPE arg) ;
   friend void ccall_bt_app_a2d_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param);
   friend void ccall_bt_app_av_sm_hdlr(uint16_t event, void *param);
   friend void ccall_bt_av_hdl_avrc_ct_evt(uint16_t event, void *param) ;
+#if 1
+  friend void ccall_bt_av_hdl_avrc_tg_evt(uint16_t event, void *param) ;
+#endif
   friend int32_t ccall_bt_app_a2d_data_cb(uint8_t *data, int32_t len);
   friend int32_t ccall_get_channel_data_wrapper(uint8_t *data, int32_t len) ;
   friend int32_t ccall_get_data_default(uint8_t *data, int32_t len) ;
@@ -185,6 +197,16 @@
       ssid_callback = callback;
     }
 
+#if 1
+    int get_discovering_count() {
+      return discovering_count;
+    }
+
+    int get_discovery_failed_count() {
+      return discovery_failed_count;
+    }
+#endif
+
   protected:
     music_data_channels_cb_t data_stream_channels_callback;
     const char *dev_name = "ESP32_A2DP_SRC";
@@ -212,6 +234,11 @@
     int32_t sound_data_current_pos = 0;
     bool has_sound_data_flag = false;
 
+#if 1
+    int discovering_count = 0;
+    int discovery_failed_count = 0;
+#endif
+
     // initialization
     bool nvs_init = true;
     bool reset_ble = false;
@@ -257,6 +284,9 @@
     virtual void bt_app_gap_callback(esp_bt_gap_cb_event_t event, esp_bt_gap_cb_param_t *param);
     /// callback function for AVRCP controller
     virtual void bt_app_rc_ct_cb(esp_avrc_ct_cb_event_t event, esp_avrc_ct_cb_param_t *param);
+#if 1
+    virtual void bt_app_rc_tg_cb(esp_avrc_tg_cb_event_t event, esp_avrc_tg_cb_param_t *param);
+#endif
     virtual void a2d_app_heart_beat(void *arg);
     /// callback function for A2DP source
     virtual void bt_app_a2d_cb(esp_a2d_cb_event_t event, esp_a2d_cb_param_t *param);
@@ -264,6 +294,10 @@
     virtual void bt_app_av_sm_hdlr(uint16_t event, void *param);
     /// avrc CT event handler
     virtual void bt_av_hdl_avrc_ct_evt(uint16_t event, void *p_param);
+#if 1
+    /// avrc TG event handler
+    virtual void bt_av_hdl_avrc_tg_evt(uint16_t event, void *p_param);
+#endif
     /// resets the last connectioin so that we can reconnect
     virtual void reset_last_connection();
 
